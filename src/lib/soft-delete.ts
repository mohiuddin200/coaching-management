import { prisma } from '@/lib/prisma';
import { logDeletionAttempt, cleanupAutoGeneratedEnrollments } from './soft-delete-utils';

export interface SoftDeleteResult {
  success: boolean;
  message: string;
  error?: string;
}

export interface SoftDeleteOptions {
  deleteReason?: 'RESIGNED' | 'TERMINATED' | 'REASSIGNED' | 'GRADUATED' | 'TRANSFERRED' | 'ERROR' | 'OTHER';
  deletedBy?: string;
  cascade?: boolean;
}

/**
 * Soft deletes a student by marking them as deleted
 */
export async function softDeleteStudent(
  studentId: string,
  options: SoftDeleteOptions = {}
): Promise<SoftDeleteResult> {
  try {
    logDeletionAttempt('student', studentId, 'attempt', { action: 'soft_delete', options });

    // Check if student exists and is not already deleted
    const existingStudent = await prisma.student.findUnique({
      where: { id: studentId }
    });

    if (!existingStudent) {
      return {
        success: false,
        message: 'Student not found'
      };
    }

    if (existingStudent.isDeleted) {
      return {
        success: false,
        message: 'Student is already deleted'
      };
    }

    // Note: Enrollment cleanup is now handled in the route handler before calling this function
    // This keeps the soft delete function focused on just updating the student record

    // Soft delete the student
    await prisma.student.update({
      where: { id: studentId },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: options.deletedBy,
        deleteReason: options.deleteReason || 'OTHER'
      }
    });
    
    logDeletionAttempt('student', studentId, 'success', {
      action: 'soft_delete',
      deleteReason: options.deleteReason,
      deletedBy: options.deletedBy
    });

    return {
      success: true,
      message: 'Student soft deleted successfully'
    };
  } catch (error) {
    logDeletionAttempt('student', studentId, 'error', {
      action: 'soft_delete',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return {
      success: false,
      message: 'Failed to soft delete student',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Soft deletes a teacher by marking them as deleted
 */
export async function softDeleteTeacher(
  teacherId: string,
  options: SoftDeleteOptions = {}
): Promise<SoftDeleteResult> {
  try {
    logDeletionAttempt('teacher', teacherId, 'attempt', { action: 'soft_delete', options });

    // Check if teacher exists and is not already deleted
    const existingTeacher = await prisma.teacher.findUnique({
      where: { id: teacherId }
    });

    if (!existingTeacher) {
      return {
        success: false,
        message: 'Teacher not found'
      };
    }

    if (existingTeacher.isDeleted) {
      return {
        success: false,
        message: 'Teacher is already deleted'
      };
    }

    // Soft delete the teacher
    const updatedTeacher = await prisma.teacher.update({
      where: { id: teacherId },
      data: {
        isDeleted: true,
        deletedAt: new Date(),
        deletedBy: options.deletedBy,
        deleteReason: options.deleteReason || 'OTHER'
      }
    });

    logDeletionAttempt('teacher', teacherId, 'success', { 
      action: 'soft_delete',
      deleteReason: options.deleteReason,
      deletedBy: options.deletedBy
    });

    return {
      success: true,
      message: 'Teacher soft deleted successfully'
    };
  } catch (error) {
    logDeletionAttempt('teacher', teacherId, 'error', { 
      action: 'soft_delete',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return {
      success: false,
      message: 'Failed to soft delete teacher',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Restores a soft deleted student
 */
export async function restoreStudent(studentId: string): Promise<SoftDeleteResult> {
  try {
    logDeletionAttempt('student', studentId, 'attempt', { action: 'restore' });

    const existingStudent = await prisma.student.findUnique({
      where: { id: studentId }
    });

    if (!existingStudent) {
      return {
        success: false,
        message: 'Student not found'
      };
    }

    if (!existingStudent.isDeleted) {
      return {
        success: false,
        message: 'Student is not deleted'
      };
    }

    const updatedStudent = await prisma.student.update({
      where: { id: studentId },
      data: {
        isDeleted: false,
        deletedAt: null,
        deletedBy: null,
        deleteReason: null
      }
    });

    logDeletionAttempt('student', studentId, 'success', { action: 'restore' });

    return {
      success: true,
      message: 'Student restored successfully'
    };
  } catch (error) {
    logDeletionAttempt('student', studentId, 'error', { 
      action: 'restore',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return {
      success: false,
      message: 'Failed to restore student',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Restores a soft deleted teacher
 */
export async function restoreTeacher(teacherId: string): Promise<SoftDeleteResult> {
  try {
    logDeletionAttempt('teacher', teacherId, 'attempt', { action: 'restore' });

    const existingTeacher = await prisma.teacher.findUnique({
      where: { id: teacherId }
    });

    if (!existingTeacher) {
      return {
        success: false,
        message: 'Teacher not found'
      };
    }

    if (!existingTeacher.isDeleted) {
      return {
        success: false,
        message: 'Teacher is not deleted'
      };
    }

    const updatedTeacher = await prisma.teacher.update({
      where: { id: teacherId },
      data: {
        isDeleted: false,
        deletedAt: null,
        deletedBy: null,
        deleteReason: null
      }
    });

    logDeletionAttempt('teacher', teacherId, 'success', { action: 'restore' });

    return {
      success: true,
      message: 'Teacher restored successfully'
    };
  } catch (error) {
    logDeletionAttempt('teacher', teacherId, 'error', { 
      action: 'restore',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return {
      success: false,
      message: 'Failed to restore teacher',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Permanently deletes a student (hard delete)
 * This should only be used for data cleanup after retention period
 */
export async function permanentDeleteStudent(studentId: string): Promise<SoftDeleteResult> {
  try {
    logDeletionAttempt('student', studentId, 'attempt', { action: 'permanent_delete' });

    // First check if student is soft deleted
    const existingStudent = await prisma.student.findUnique({
      where: { id: studentId }
    });

    if (!existingStudent) {
      return {
        success: false,
        message: 'Student not found'
      };
    }

    if (!existingStudent.isDeleted) {
      return {
        success: false,
        message: 'Cannot permanently delete active student. Soft delete first.'
      };
    }

    // Delete related records first
    await prisma.attendance.deleteMany({
      where: { studentId }
    });

    await prisma.enrollment.deleteMany({
      where: { studentId }
    });

    await prisma.studentPayment.deleteMany({
      where: { studentId }
    });

    // Finally delete the student
    await prisma.student.delete({
      where: { id: studentId }
    });

    logDeletionAttempt('student', studentId, 'success', { action: 'permanent_delete' });

    return {
      success: true,
      message: 'Student permanently deleted'
    };
  } catch (error) {
    logDeletionAttempt('student', studentId, 'error', { 
      action: 'permanent_delete',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return {
      success: false,
      message: 'Failed to permanently delete student',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Permanently deletes a teacher (hard delete)
 * This should only be used for data cleanup after retention period
 */
export async function permanentDeleteTeacher(teacherId: string): Promise<SoftDeleteResult> {
  try {
    logDeletionAttempt('teacher', teacherId, 'attempt', { action: 'permanent_delete' });

    // First check if teacher is soft deleted
    const existingTeacher = await prisma.teacher.findUnique({
      where: { id: teacherId }
    });

    if (!existingTeacher) {
      return {
        success: false,
        message: 'Teacher not found'
      };
    }

    if (!existingTeacher.isDeleted) {
      return {
        success: false,
        message: 'Cannot permanently delete active teacher. Soft delete first.'
      };
    }

    // Delete related records first
    await prisma.classSection.deleteMany({
      where: { teacherId }
    });

    await prisma.class.deleteMany({
      where: { teacherId }
    });

    await prisma.teacherPayment.deleteMany({
      where: { teacherId }
    });

    // Finally delete the teacher
    await prisma.teacher.delete({
      where: { id: teacherId }
    });

    logDeletionAttempt('teacher', teacherId, 'success', { action: 'permanent_delete' });

    return {
      success: true,
      message: 'Teacher permanently deleted'
    };
  } catch (error) {
    logDeletionAttempt('teacher', teacherId, 'error', { 
      action: 'permanent_delete',
      error: error instanceof Error ? error.message : 'Unknown error'
    });
    
    return {
      success: false,
      message: 'Failed to permanently delete teacher',
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
}

/**
 * Gets soft deleted students with pagination
 */
export async function getSoftDeletedStudents(page: number = 1, limit: number = 10) {
  const skip = (page - 1) * limit;
  
  const [students, total] = await Promise.all([
    prisma.student.findMany({
      where: { isDeleted: true },
      skip,
      take: limit,
      orderBy: { deletedAt: 'desc' },
      include: {
        level: {
          select: { name: true }
        }
      }
    }),
    prisma.student.count({
      where: { isDeleted: true }
    })
  ]);

  return {
    students,
    total,
    page,
    totalPages: Math.ceil(total / limit)
  };
}

/**
 * Gets soft deleted teachers with pagination
 */
export async function getSoftDeletedTeachers(page: number = 1, limit: number = 10) {
  const skip = (page - 1) * limit;
  
  const [teachers, total] = await Promise.all([
    prisma.teacher.findMany({
      where: { isDeleted: true },
      skip,
      take: limit,
      orderBy: { deletedAt: 'desc' }
    }),
    prisma.teacher.count({
      where: { isDeleted: true }
    })
  ]);

  return {
    teachers,
    total,
    page,
    totalPages: Math.ceil(total / limit)
  };
}